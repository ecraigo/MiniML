(** A mini-ML
    @author Stuart M. Shieber

    This module implements a small untyped ML-like language under
    various operational semantics.
 *)

open Expr ;;

let fmt = Printf.sprintf ;;

(* Exception for evaluator runtime generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime generated by an explicit "raise" construct *)
exception EvalException ;;

module type Env_type = sig
    type env
    type value =
      | Val of expr
      | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : Env_type =
  struct

    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    (* Seems rather pointless to me to have this exception here, since
     * you can't really do much with it if it's not in the sig. *)
    exception EnvUnbound

    (* Creates an empty environment *)
    let create () : env = []

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp: expr) (env: env) : value =
      Closure (exp, env)

    (* Looks up the value of a variable in the environment *)
    let lookup (env: env) (varname: varid) : value =
      try
	let found = List.assoc varname env in !found
      with Not_found -> raise EnvUnbound

    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    let extend (env: env) (varname: varid) (loc: value ref) : env =
      if List.mem_assoc varname env
      then let env = List.remove_assoc varname env in
	   (varname, loc) :: env
      else (varname, loc) :: env

    (* Returns a printable string representation of an environment *)
    let rec env_to_string (env: env) : string =
      List.map (fun (v, l) ->
		fmt "(%s | %s)" v (value_to_string !l)) env
      |> String.concat ", "

    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
    and value_to_string ?(printenvp : bool = true) (v: value) : string =
      match v with
      | Val exp -> exp_to_string exp
      | Closure (exp, env) ->
	 "Closure - Expr: " ^
	   exp_to_string exp ^
	     if printenvp then ", Env: " ^ (env_to_string env)
	     else ""
  end
;;

(* Helpers for eval functions *)
let unop_eval op e =
  match op with
  | "~" -> (match e with
	    | Num _ -> Unop ("~", e)
	    | _ -> raise (EvalError "Negation operator only takes integers."))
  | _ -> raise (EvalError ("Undefined unary operator " ^ op))
;;

let binop_int f e1 e2 =
  match e1, e2 with
  | Num n1, Num n2 -> Num (f n1 n2)
  | _, _ ->
     raise (EvalError "This binary operator must take two integers.")
;;

let binop_cmp op e1 e2 =
  (* OCaml's draconian type-checking means that as soon as you
   * use an arbitrary function f on two 'as you have to use it
   * on two 'as forever, despite that this property is
   * bypassed for the comparison functions (<) and (=).
   * Here's a convoluted workaround to a stupid problem. *)
  match e1, e2 with
  (* Wish I could use these match cases at the same time, but I
   * cannot, because once again they are differently typed. *)
  | Num n1, Num n2 ->
     (match op with
      | "=" -> Bool (n1 = n2)
      | "<" -> Bool (n1 < n2)
      | _ -> raise (EvalError "Undefined operator"))
  | Bool b1, Bool b2 ->
     (match op with
      | "=" -> Bool (b1 = b2)
      | "<" -> Bool (b1 < b2)
      | _ -> raise (EvalError "Undefined operator"))
  | _, _ ->
     raise (EvalError ("This binary operator must take " ^
			 "two arguments of the same type."))
;;

let binop_eval op e1 e2 =
  match op with
  | "+" -> binop_int (+) e1 e2
  | "-" -> binop_int (-) e1 e2
  | "*" -> binop_int ( * ) e1 e2
  | "<" | "=" -> binop_cmp op e1 e2
  | _ -> raise (EvalError ("undefined binary operator " ^ op))

(* Perform common manipulations on an evaluated expression. *)
let wrapper result =
  let aux =
    match result with
    (* Deal with negative numbers not being representable. *)
    | Num n -> if n < 0 then Unop ("~", Num (abs n)) else result
    | _ -> result in
  Env.Val aux ;;

(* The evaluation function: Returns the result of type `value` of
   evaluating the expression `exp` in the environment `env`. *)
let eval_s expression _env =
  let rec aux exp =
    match exp with
    | Var v -> raise (EvalError ("Unbound variable " ^ v))
    | Num _ | Bool _ -> exp
    | Unop (op, e) -> let value = aux e in unop_eval op value
    | Binop (op, e1, e2) ->
       let v1, v2 = aux e1, aux e2 in binop_eval op v1 v2
    | Conditional (c, t, f) ->
       (match aux c with
	| Bool true -> aux t
	| Bool false -> aux f
	| _ -> raise (EvalError ("Condition must be a boolean")))
    | Fun (_, _) -> exp
    | Let (v, to_sub, e) -> aux (subst v to_sub e)
    | Letrec (v, to_sub, e) ->
       let chained = subst v (Letrec (v, to_sub, Var v)) to_sub in
       aux (subst v chained e)
    | Raise -> raise EvalException
    | Unassigned -> raise (EvalError "All variables must be assigned")
    | App (f, e) -> (match (aux f) with
		    | Fun (v, sub_in) -> aux (subst v (aux e) sub_in)
		    | _ -> raise (EvalError
				    "A non-function cannot be applied"))
    | Ref _ -> raise (EvalError "No refs allowed in substitution model")
  in aux expression |> wrapper ;;

(* Helper functions for eval_d in particular *)
(* No having to deal with closures in dynamic scoping. *)
let lookup_d env varname =
  let open Env in
  try
    match lookup env varname with
    | Val v -> v
    | Closure _ -> raise (EvalError "Closures should not occur in eval_d.")
  with _ -> raise (EvalError ("Unbound variable " ^ varname))

(* A helper function to wrap expressions for "extend" *)
let ex_d e = ref (Env.Val e) ;;

let eval_d_ref expression environment =
  let open Env in
  let rec aux exp env =
    match exp with
    | Var v -> aux (lookup_d env v) env
    | Num _ | Bool _ -> exp
    | Unop (op, e) ->
       let value = aux e env in
       if op = "!" then
	 (match value with
	  | Ref ex -> aux !ex env
	  | _ -> raise (EvalError "Bang operator only takes references"))
			else unop_eval op value
    | Binop (op, e1, e2) ->
       if op = ":=" then
	 (match aux e1 env with
	  | Ref r -> r := e2; Ref r
	  | _ -> raise (EvalError ("Mutation only works on refs")))
       else let v1, v2 = aux e1 env, aux e2 env in binop_eval op v1 v2
    | Conditional (c, t, f) ->
       (match aux c env with
	| Bool true -> aux t env
	| Bool false -> aux f env
	| _ -> raise (EvalError ("Condition must be a boolean")))
    | Fun (_, _) -> exp
    | Let (v, def, e) ->
	     aux e (extend env v (aux def env |> ex_d))
    | Letrec (v, def, e) ->
       let eval_def = aux def (extend env v (ex_d Unassigned)) in
       aux e (extend env v (eval_def |> ex_d))
    | Raise -> raise EvalException
    | Unassigned -> raise (EvalError "Malformed Letrec")

    | App (f, e) -> (match (aux f env) with
		     | Fun (v, def) ->
		       aux def (extend env v (aux e env |> ex_d))
		     | _ -> raise (EvalError
				   "A non-function cannot be applied"))
    | Ref _ -> exp
  in aux expression environment |> wrapper ;;

let evaluate = eval_d_ref ;;
